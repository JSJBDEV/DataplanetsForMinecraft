package ace.actually.dataplanets;

import com.gregtechceu.gtceu.api.data.chemical.material.Material;
import com.gregtechceu.gtceu.api.data.tag.TagPrefix;
import com.gregtechceu.gtceu.common.data.GTMaterialBlocks;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.NbtIo;
import net.minecraft.nbt.StringTag;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.RandomSource;
import net.minecraft.world.level.block.state.BlockState;
import org.apache.commons.io.FileUtils;
import org.checkerframework.checker.units.qual.C;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.UUID;

//TODO: remove all datapack file writing as it's no longer necessary, save the CompoundTag to .dat file.
public class StarSystemCreator {

    public static String DATALOC;
    public static String RECLOC;
    public static List<Material> FLUIDABLE = null;
    public static final ResourceLocation SYSTEM_DATA = ResourceLocation.tryBuild("dataplanets","system_data");

    public static void makeSystem()
    {



        try {
            String uuid = UUID.randomUUID().toString();
            writeLinesCond(new File(DATALOC+"pack"+uuid+"\\pack.mcmeta"), List.of("""
                    {
                    \t"pack": {
                    \t\t"description": "Generated by Dataplanets",
                    \t\t"pack_format": 48
                    \t}
                    }"""));
            writeLinesCond(new File(RECLOC+"pack"+uuid+"\\pack.mcmeta"), List.of("""
                    {
                    \t"pack": {
                    \t\t"description": "Generated by Dataplanets",
                    \t\t"pack_format": 34
                    \t}
                    }"""));



            inventSystem(uuid);

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }

    private static final String[] CODE = new String[]{"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"};
    private static final String[] WEIGHTED_BOOLEANS = new String[]{"false","false","false","true"};
    private static final String[] REVERSED_WEIGHTED_BOOLEANS = new String[]{"true","true","true","false"};
    private static final String[] SURFACE_BLOCKS = new String[]{"gcyr:moon_stone","gcyr:moon_cobblestone","gcyr:venusian_regolith","gcyr:martian_rock"};
    private static void inventSystem(String uuid)
    {
        RandomSource random = RandomSource.create();
        String systemName = CODE[random.nextInt(CODE.length)]+CODE[random.nextInt(CODE.length)]+random.nextInt(1000);
        int rocketTier = random.nextInt(3)+1;


        CompoundTag systemData = new CompoundTag();
        systemData.putString("systemName",systemName);
        systemData.putInt("rocketTier",rocketTier);

        List<String> solar_system = List.of("{\n" +
                "  \"galaxy\": \"gcyr:milky_way\",\n" +
                "  \"solar_system\": \"dataplanets:SW\",\n".replace("SW",systemName) +
                "  \"sun\": \"gcyr:textures/sky/sunmenu.png\",\n" +
                "  \"sun_scale\": 60,\n" +
                "  \"button_color\": 4284861158,\n" +
                "  \"ring_color\": 3357815419\n" +
                "}");

        try {
            writeLinesCond(new File(RECLOC+"pack"+uuid+"\\assets\\dataplanets\\gcyr\\planet_assets\\solar_systems\\"+systemName+".json"),solar_system);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }


        StringBuilder langFile = new StringBuilder("{\"dataplanets.").append(systemName).append("\":\"");
        String rebuild = systemName.toUpperCase();
        rebuild = rebuild.substring(0,2)+" "+rebuild.substring(2);
        langFile.append(rebuild).append("\",");

        for (int i = 0; i < 5; i++) {
            CompoundTag planetData = new CompoundTag();
            String subname = CODE[i];
            String planetName = systemName+subname;
            planetData.putString("name",planetName);
            planetData.putFloat("gravity",(float)random.nextInt(1500)/100f);
            planetData.putString("hasAtmosphere",WEIGHTED_BOOLEANS[random.nextInt(WEIGHTED_BOOLEANS.length)]);
            planetData.putInt("yearDays",random.nextInt(1,1000));


            int initalTemperature = random.nextInt(1000);

            //a planet with an atmosphere is more likely to have a reasonable temperature
            if(planetData.getString("hasAtmosphere").equals("true") && initalTemperature<100)
            {
                initalTemperature+=100;
            }

            //temperature limits solar power - that's wierd right?
            //a higher solar power would imply a higher temperature from the sun.
            //(this is a massive simplification when you consider different radiation types...)
            //however higher temperatures can be generated in a planet without its star (tidal flexing/heating, volcanic activity etc)
            //hence, as temperature isn't necesarily dependent on the star, its this way round
            //MAYBE: does this make sense?
            planetData.putInt("temperature",initalTemperature);

            //solar power 50 is REALLY high, Mercury has 19 at 440K
            //however, the planet needs a temeprature of 1000 to get 49 (upper bounds)
            //that's rather warm.
            //nicely, a planet with temperature 401 has a chance of getting 20 (still 1-20 however)
            planetData.putInt("solarPower",random.nextInt((planetData.getInt("temperature")/20)+1));

            planetData.putString("hasOxygen",WEIGHTED_BOOLEANS[random.nextInt(WEIGHTED_BOOLEANS.length)]);

            String effects;
            if(planetData.getString("hasAtmosphere").equals("true"))
            {
                effects="minecraft:overworld";
            }
            else
            {
                effects="minecraft:the_end";
            }

            planetData.putString("effects",effects);

            List<String> planet = List.of("{\n" +

                    "\"translation\": \"level.NAME\",\n".replace("NAME",planetName) +
                    "\"galaxy\": \"gcyr:milky_way\",\n" + //TODO: become intergalactic.

                    "\"solar_system\": \"dataplanets:SOMEWHERE\",\n".replace("SOMEWHERE",systemName) +
                    "\"world\": \"WORLD\",\n".replace("WORLD","dataplanets:"+planetName) +
                    "\"orbit_world\": \"ORBIT\",\n".replace("ORBIT","dataplanets:"+planetName+"_orbit") +

                    "\"rocket_tier\": RT,\n".replace("RT",""+rocketTier) +

                    "\"gravity\": GS,\n".replace("GS",""+planetData.getFloat("gravity")) +

                    "\"has_atmosphere\": BOOL,\n".replace("BOOL", planetData.getString("hasAtmosphere")) +
                    "\"days_in_year\": DAYS,\n".replace("DAYS",""+planetData.getInt("yearDays")) +
                    "\"temperature\": TP,\n".replace("TP",""+planetData.getInt("temperature")) +
                    "\"solar_power\": SP,\n".replace("SP",""+planetData.getInt("solarPower")) +
                    "\"has_oxygen\": BOOL,\n".replace("BOOL", planetData.getString("hasOxygen")) +
                    "\"button_color\": 893717\n" +
                    "}");


            String ultrawarm;
            if(planetData.getInt("temperature")>400)
            {
                ultrawarm="true";
            }
            else
            {
                ultrawarm="false";
            }
            String skylight;
            if(planetData.getInt("solarPower")<6)
            {
                skylight="false";
            }
            else
            {
                skylight="true";
            }


            List<String> dimension_type = List.of("{\n" +
                    "  \"ultrawarm\": HOT,\n".replace("HOT",ultrawarm) +
                    "  \"natural\": true,\n" +
                    "  \"piglin_safe\": HOT,\n".replace("HOT",ultrawarm) +
                    "  \"respawn_anchor_works\": false,\n" +
                    "  \"bed_works\": true,\n" +
                    "  \"has_raids\": false,\n" +
                    "  \"has_skylight\": BB,\n".replace("BB",skylight) +
                    "  \"has_ceiling\": false,\n" +
                    "  \"coordinate_scale\": 1.0,\n" +
                    "  \"ambient_light\": 0.0,\n" +
                    "  \"logical_height\": 384,\n" +
                    "  \"infiniburn\": \"#minecraft:infiniburn_overworld\",\n" +
                    "  \"min_y\": -64,\n" +
                    "  \"height\": 384,\n" +
                    "  \"effects\": \"EFF\",\n".replace("EFF",planetData.getString("effects")) +
                    "  \"monster_spawn_block_light_limit\": 0,\n" +
                    "  \"monster_spawn_light_level\": {\n" +
                    "    \"type\": \"minecraft:uniform\",\n" +
                    "    \"value\": {\"min_inclusive\": 0,\n" +
                    "    \"max_inclusive\": 7}\n" +
                    "  }\n" +
                    "}");

            //TODO: multiple biomes per planet
            List<String> dimension = List.of("{\n" +
                    "  \"type\": \"ID\",\n".replace("ID","dataplanets:"+planetName) +
                    "  \"generator\": {\n" +
                    "    \"type\": \"minecraft:noise\",\n" +
                    "    \"settings\": \"ID\",\n".replace("ID","dataplanets:"+planetName) +
                    "    \"biome_source\": {\n" +
                    "      \"type\": \"minecraft:multi_noise\",\n" +
                    "      \"biomes\": [\n" +
                    "        {\n" +
                    "          \"biome\": \"BIOME\",\n".replace("BIOME","dataplanets:"+planetName+"_terrain") +
                    "          \"parameters\": {\n" +
                    "            \"temperature\": 0,\n" +
                    "            \"humidity\": 0,\n" +
                    "            \"continentalness\": 0,\n" +
                    "            \"erosion\": 0,\n" +
                    "            \"weirdness\": W,\n".replace("W",""+(float)random.nextInt(0,10)/10f) +
                    "            \"depth\": 0,\n" +
                    "            \"offset\": O\n".replace("O",""+(float)random.nextInt(0,10)/10f) +
                    "          }\n" +
                    "        }\n" +
                    "      ]\n" +
                    "    }\n" +
                    "  }\n" +
                    "}");

            List<String> orbit_dimension = List.of("{\n" +
                    "  \"type\": \"gcyr:space\",\n" +
                    "  \"generator\": {\n" +
                    "    \"type\": \"gcyr:space\"\n" +
                    "  }\n" +
                    "}");

            planetData.putInt("skyColour",random.nextInt(16777215));
            planetData.putInt("fogColour",random.nextInt(16777215));
            planetData.putInt("waterColour",random.nextInt(16777215));
            planetData.putInt("waterFogColour",random.nextInt(16777215));
            planetData.putInt("grassColour",random.nextInt(16777215));
            planetData.putInt("foliageColour",random.nextInt(16777215));
            planetData.putString("generalBlock",SURFACE_BLOCKS[random.nextInt(SURFACE_BLOCKS.length)]);

            List<String> biome = List.of("{\n" +
                    "  \"temperature\": TM,\n".replace("TM",""+(float)planetData.getInt("temperature")/500f) +
                    "  \"downfall\": 0,\n" +
                    "  \"has_precipitation\": false,\n" +
                    "  \"effects\": {\n" +
                    "    \"sky_color\": C,\n".replace("C",""+planetData.getInt("skyColour")) +
                    "    \"fog_color\": C,\n".replace("C",""+planetData.getInt("fogColour")) +
                    "    \"water_color\": C,\n".replace("C",""+planetData.getInt("waterColour")) +
                    "    \"water_fog_color\": C,\n".replace("C",""+planetData.getInt("waterFogColour")) +
                    "    \"grass_color\": C,\n".replace("C",""+planetData.getInt("grassColour")) +
                    "    \"foliage_color\": C\n".replace("C",""+planetData.getInt("foliageColour")) +
                    "  },\n" +
                    "  \"creature_spawn_probability\": 0,\n" + //TODO: low level complex organisms
                    "  \"spawners\": {\n" +
                    "  },\n" +
                    "  \"spawn_costs\": {\n" +
                    "  },\n" +
                    "  \"carvers\": {\n" +
                    "    \"air\": [\n" +
                    "      \"minecraft:cave\",\n" +
                    "      \"minecraft:cave_extra_underground\",\n" +
                    "      \"minecraft:canyon\"\n" +
                    "    ]\n" +
                    "  },\n" +
                    "  \"features\": [\n" +
                    "    [\n" +
                            shouldGenDripstone(random)+
                            genLakes(planetData,uuid,random)+
                            genRocks(planetData,uuid,random)+
                            genOre(random,uuid,planetData)+
                    "    ]\n" +
                    "  ]\n" +
                    "}");

            //planetData.putInt("noiseSizeX",random.nextInt(1,5));
            //planetData.putInt("noiseSizeY",random.nextInt(1,3));
            planetData.putFloat("nr1", (float) random.nextInt(1800) /1000f);
            planetData.putFloat("nr2", (float) random.nextInt(2000) /1000f);
            planetData.putFloat("nr3", (float) random.nextInt(2000) /1000f);

            String alsoMakeGrass  = "";
            if(planetData.getString("hasAtmosphere").equals("true") && planetData.getString("hasOxygen").equals("true"))
            {
                alsoMakeGrass = alsoMakeGrass();
            }





            //TODO: default fluid could be anything, right?
            List<String> noise_settings = List.of("{\n" +
                    "  \"sea_level\": 63,\n" +
                    "  \"disable_mob_generation\": false,\n" +
                    "  \"aquifers_enabled\": false,\n" +
                    "  \"ore_veins_enabled\": false,\n" +
                    "  \"legacy_random_source\": false,\n" +
                    "  \"default_block\": {\n" +
                    "    \"Name\": \"SB\"\n".replace("SB",planetData.getString("generalBlock")) +
                    "  },\n" +
                    "  \"default_fluid\": {\n" +
                    "    \"Name\": \"minecraft:air\",\n" +
                    "    \"Properties\": {\n" +
                    "      \"level\": \"0\"\n" +
                    "    }\n" +
                    "  },\n" +
                    "  \"noise\": {\n" +
                    "    \"min_y\": -64,\n" +
                    "    \"height\": 384,\n" +
                    "    \"size_horizontal\": 2,\n" +
                    "    \"size_vertical\": 2\n" +
                    "  },\n" +
                    "  \"noise_router\": {\n" +
                    "    \"barrier\": 0,\n" +
                    "    \"fluid_level_floodedness\": 0,\n" +
                    "    \"fluid_level_spread\": 0,\n" +
                    "    \"lava\": 0,\n" +
                    "    \"temperature\": 0,\n" +
                    "    \"vegetation\": 0,\n" +
                    "    \"continents\": 0,\n" +
                    "    \"erosion\": 0,\n" +
                    "    \"depth\": 0,\n" +
                    "    \"ridges\": 0,\n" +
                    "    \"initial_density_without_jaggedness\": 0,\n" +
                    "    \"final_density\": FD,\n".replace("FD",makeFinalDensity(planetData)) +
                    "    \"vein_toggle\": 0,\n" +
                    "    \"vein_ridged\": 0,\n" +
                    "    \"vein_gap\": 0\n" +
                    "  },\n" +
                    "  \"spawn_target\": [],\n" +
                    "  \"surface_rule\": {\n" +
                    "    \"type\": \"minecraft:sequence\",\n" +
                    "    \"sequence\": [SE]\n".replace("SE", makeBedrockLayer()+alsoMakeGrass) +
                    "  }\n" +
                    "}");

            planetData.putFloat("radiusClient",(((50f-planetData.getInt("solarPower")) /10f)+random.nextFloat()));
            planetData.putInt("scaleClient",random.nextInt(5,20));

            List<String> planet_rings = List.of("{\n" +
                    "  \"galaxy\": \"gcyr:milky_way\",\n" +
                    "  \"solar_system\": \"dataplanets:SOMEWHERE\",\n".replace("SOMEWHERE",systemName) +
                    "  \"texture\": \"gcyr:textures/sky/deimos.png\",\n" +
                    "  \"speed\": S,\n".replace("S",""+planetData.getInt("yearDays")) +
                    "  \"scale\": S,\n".replace("S",""+planetData.getInt("scaleClient")) +
                    "  \"radius\": X\n".replace("X",""+planetData.getFloat("radiusClient")) +
                    "}");

            List<String> sky_renderer = List.of("{\n" +
                    "  \"world\": \"dataplanets:SW\",\n".replace("SW",planetName) +
                    "  \"stars\": {\n" +
                    "    \"fancy_count\": 13000,\n" +
                    "    \"fast_count\": 6000,\n" +
                    "    \"colored_stars\": true,\n" +
                    "    \"daylight_visible\": true\n" +
                    "  },\n" +
                    "  \"sunset_color\": \"none\",\n" +
                    "  \"dimension_effects\": {\n" +
                    "    \"type\": \"none\"\n" +
                    "  },\n" +
                    "  \"cloud_effects\": \"none\",\n" +
                    "  \"weather_effects\": \"none\",\n" +
                    "  \"horizon_angle\": 0,\n" +
                    "  \"sky_objects\": [\n" +
                    "    {\n" +
                    "      \"texture\": \"gcyr:textures/sky/sun.png\",\n" +
                    "      \"blending\": true,\n" +
                    "      \"render_type\": \"dynamic\",\n" +
                    "      \"scale\": SZ,\n".replace("SZ",""+(planetData.getInt("solarPower")+1)) +
                    "      \"rotation\": [\n" +
                    "        0.0,\n" +
                    "        -90.0,\n" +
                    "        0.0\n" +
                    "      ]\n" +
                    "    }\n" +
                    "  ]\n" +
                    "}");

            List<String> orbit_skybox = List.of("{\n" +
                    "  \"world\": \"dataplanets:SW_orbit\",\n".replace("SW",planetName) +
                    "  \"stars\": {\n" +
                    "    \"fancy_count\": 13000,\n" +
                    "    \"fast_count\": 6000,\n" +
                    "    \"colored_stars\": true,\n" +
                    "    \"daylight_visible\": true\n" +
                    "  },\n" +
                    "  \"sunset_color\": \"none\",\n" +
                    "  \"dimension_effects\": {\n" +
                    "    \"type\": \"none\"\n" +
                    "  },\n" +
                    "  \"cloud_effects\": \"none\",\n" +
                    "  \"weather_effects\": \"none\",\n" +
                    "  \"horizon_angle\": 0,\n" +
                    "  \"sky_objects\": [\n" +
                    "    {\n" +
                    "      \"texture\": \"gcyr:textures/sky/mercury.png\",\n" +
                    "      \"blending\": true,\n" +
                    "      \"render_type\": \"dynamic\",\n" +
                    "      \"scale\": SZ,\n".replace("SZ",""+(planetData.getInt("solarPower")+2)) +
                    "      \"rotation\": [\n" +
                    "        0.0,\n" +
                    "        -90.0,\n" +
                    "        0.0\n" +
                    "      ]\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"texture\": \"gcyr:textures/sky/sun.png\",\n" +
                    "      \"blending\": true,\n" +
                    "      \"render_type\": \"static\",\n" +
                    "      \"scale\": 15.0,\n" +
                    "      \"rotation\": [\n" +
                    "        0.0,\n" +
                    "        0.0,\n" +
                    "        0.0\n" +
                    "      ]\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"texture\": \"gcyr:textures/sky/light.png\",\n" +
                    "      \"blending\": true,\n" +
                    "      \"render_type\": \"static\",\n" +
                    "      \"scale\": 20.0,\n" +
                    "      \"color\": 16777164,\n" +
                    "      \"rotation\": [\n" +
                    "        0.0,\n" +
                    "        0.0,\n" +
                    "        0.0\n" +
                    "      ]\n" +
                    "    }\n" +
                    "  ]\n" +
                    "}");


            langFile.append("\"level.").append(planetName).append("\":\"");
            rebuild = planetName.toUpperCase();
            rebuild = rebuild.substring(0,2)+" "+rebuild.substring(2,rebuild.length()-1)+" "+rebuild.toLowerCase().charAt(rebuild.length()-1);
            langFile.append(rebuild).append("\",");

            try {
                writeLinesCond(new File(RECLOC+"pack"+uuid+"\\assets\\dataplanets\\gcyr\\planet_assets\\planet_rings\\"+systemName+"\\"+planetName+".json"),planet_rings);
                writeLinesCond(new File(RECLOC+"pack"+uuid+"\\assets\\dataplanets\\gcyr\\planet_assets\\sky_renderers\\"+planetName+".json"),sky_renderer);
                writeLinesCond(new File(RECLOC+"pack"+uuid+"\\assets\\dataplanets\\gcyr\\planet_assets\\sky_renderers\\"+planetName+"_orbit.json"),orbit_skybox);
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\gcyr\\planets\\"+planetName+".json"),planet);
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\dimension_type\\"+planetName+".json"),dimension_type);
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\dimension\\"+planetName+".json"),dimension);
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\dimension\\"+planetName+"_orbit.json"),orbit_dimension);
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\worldgen\\biome\\"+planetName+"_terrain.json"),biome);
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\worldgen\\noise_settings\\"+planetName+".json"),noise_settings);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            systemData.put(planetName,planetData);
        }
        CompoundTag tag = getDynamicDataOrNew();
        tag.put(systemName,systemData);
        writeToDynamic(tag);
        try {
            writeLinesCond(new File(RECLOC+"pack"+uuid+"\\assets\\dataplanets\\lang\\en_us.json"),List.of(langFile.substring(0,langFile.length()-1)+"}"));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }


    }

    public static CompoundTag getDynamicDataOrNew()
    {
        CompoundTag tag;
        File storage = new File("./dataplanets_dynamic_data.dat");
        if(storage.exists())
        {
            try {
                tag = NbtIo.readCompressed(new File("./dataplanets_dynamic_data.dat"));
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        else
        {
            tag = new CompoundTag();
        }
        return tag;
    }
    private static void writeToDynamic(CompoundTag tag)
    {
        File storage = new File("./dataplanets_dynamic_data.dat");
        try {
            NbtIo.writeCompressed(tag,storage);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static String genOre(RandomSource random,String uuid,CompoundTag planetData)
    {

        String oreBase = planetData.getString("generalBlock");
        if(oreBase.contains("mart"))
        {
            oreBase="mars";
        }
        if(oreBase.contains("venus"))
        {
            oreBase="venus";
        }
        if(oreBase.contains("mercury"))
        {
            oreBase="mercury";
        }

        List<Material> ORES = GTMaterialBlocks.MATERIAL_BLOCKS.row(TagPrefix.ore).keySet().stream().toList();
        Material oreMat = ORES.get(random.nextInt(ORES.size()));
        BlockState oreState = GTMaterialBlocks.MATERIAL_BLOCKS.get(TagPrefix.ore,oreMat).getDefaultState();
        ResourceLocation orerl = BuiltInRegistries.BLOCK.getKey(oreState.getBlock());
        String ore = orerl.toString();
        ListTag ores;
        if(planetData.contains("planet_ores"))
        {
            ores = (ListTag) planetData.get("planet_ores");
        }
        else
        {
            ores = new ListTag();
        }
        ores.add(StringTag.valueOf(ore));
        planetData.put("planet_ores",ores);


        List<String> configured_ore = List.of("{\n" +
                "  \"type\": \"minecraft:ore\",\n" +
                "  \"config\": {\n" +
                "    \"discard_chance_on_air_exposure\": 0,\n" +
                "    \"size\": 10,\n" +
                "    \"targets\": [\n" +
                "      {\n" +
                "        \"state\": {\n" +
                "          \"Name\": \"RL\"\n".replace("RL",ore) +
                "        },\n" +
                "        \"target\": {\n" +
                "          \"predicate_type\": \"minecraft:tag_match\",\n" +
                "          \"tag\": \"minecraft:dirt\"\n" +
                "        }\n" +
                "      }\n" +
                "    ]\n" +
                "  }\n" +
                "}");

        String reform = ore.replace(":","_");
        List<String> placed_ore = List.of("{\n" +
                "  \"feature\": \"dataplanets:ORE\",\n".replace("ORE",reform) +
                "  \"placement\": [\n" +
                "    {\n" +
                "      \"type\": \"minecraft:count\",\n" +
                "      \"count\": V\n".replace("V",""+random.nextInt(4,32)) +
                "    },\n" +
                "    {\n" +
                "      \"type\": \"minecraft:in_square\"\n" +
                "    },\n" +
                "    {\n" +
                "      \"type\": \"minecraft:height_range\",\n" +
                "      \"height\": {\n" +
                "        \"type\": \"minecraft:trapezoid\",\n" +
                "        \"max_inclusive\": {\n" +
                "          \"absolute\": 112\n" +
                "        },\n" +
                "        \"min_inclusive\": {\n" +
                "          \"absolute\": -16\n" +
                "        }\n" +
                "      }\n" +
                "    },\n" +
                "    {\n" +
                "      \"type\": \"minecraft:biome\"\n" +
                "    }\n" +
                "  ]\n" +
                "}");


        try {
            writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\worldgen\\placed_feature\\"+reform+".json"),placed_ore);
            writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\worldgen\\configured_feature\\"+reform+".json"),configured_ore);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return ",\""+"dataplanets:ORE\"".replace("ORE",reform);
    }



    private static String shouldGenDripstone(RandomSource source)
    {
        //\"minecraft:large_dripstone\",\n" +
        //                    "      \"minecraft:dripstone_cluster\",\n" +
        //                    "      \"minecraft:pointed_dripstone\"\n" +
        StringBuilder stringBuilder = new StringBuilder();
        if(source.nextInt(5)==0)
        {
            stringBuilder.append("\"minecraft:dripstone_cluster\",\n");
        }
        if(source.nextInt(5)==0)
        {
            stringBuilder.append("\"minecraft:large_dripstone\",\n");
        }
        if(source.nextInt(5)==0)
        {
            stringBuilder.append("\"minecraft:pointed_dripstone\",\n");
        }
        String v = stringBuilder.toString();

        if(v.isEmpty()) return "";
        return v.substring(0,v.length()-1);
    }



    private static String makeBedrockLayer()
    {
        return "{\n" +
                "        \"type\": \"minecraft:condition\",\n" +
                "        \"if_true\": {\n" +
                "          \"type\": \"minecraft:vertical_gradient\",\n" +
                "          \"random_name\": \"minecraft:bedrock_floor\",\n" +
                "          \"true_at_and_below\": {\n" +
                "            \"above_bottom\": 0\n" +
                "          },\n" +
                "          \"false_at_and_above\": {\n" +
                "            \"above_bottom\": 5\n" +
                "          }\n" +
                "        },\n" +
                "        \"then_run\": {\n" +
                "          \"type\": \"minecraft:block\",\n" +
                "          \"result_state\": {\n" +
                "            \"Name\": \"minecraft:bedrock\"\n" +
                "          }\n" +
                "        }\n" +
                "      }";
    }
    private static String alsoMakeGrass()
    {
        return ",{\n" +
                "                \"type\": \"minecraft:condition\",\n" +
                "                \"if_true\": {\n" +
                "                  \"type\": \"minecraft:noise_threshold\",\n" +
                "                  \"max_threshold\": 1.7976931348623157e+308,\n" +
                "                  \"min_threshold\": -0.12121212121212122,\n" +
                "                  \"noise\": \"minecraft:surface\"\n" +
                "                },\n" +
                "                \"then_run\": {\n" +
                "                  \"type\": \"minecraft:sequence\",\n" +
                "                  \"sequence\": [\n" +
                "                    {\n" +
                "                      \"type\": \"minecraft:condition\",\n" +
                "                      \"if_true\": {\n" +
                "                        \"type\": \"minecraft:water\",\n" +
                "                        \"add_stone_depth\": false,\n" +
                "                        \"offset\": 0,\n" +
                "                        \"surface_depth_multiplier\": 0\n" +
                "                      },\n" +
                "                      \"then_run\": {\n" +
                "                        \"type\": \"minecraft:block\",\n" +
                "                        \"result_state\": {\n" +
                "                          \"Name\": \"minecraft:grass_block\",\n" +
                "                          \"Properties\": {\n" +
                "                            \"snowy\": \"false\"\n" +
                "                          }\n" +
                "                        }\n" +
                "                      }\n" +
                "                    },\n" +
                "                    {\n" +
                "                      \"type\": \"minecraft:block\",\n" +
                "                      \"result_state\": {\n" +
                "                        \"Name\": \"minecraft:dirt\"\n" +
                "                      }\n" +
                "                    }\n" +
                "                  ]\n" +
                "                }\n" +
                "              }";
    }

    private static String makeFinalDensity(CompoundTag planetData)
    {
        return "{\n" +
                "  \"type\": \"minecraft:add\",\n" +
                "  \"argument1\": {\n" +
                "    \"type\": \"minecraft:y_clamped_gradient\",\n" +
                "    \"from_y\": -64,\n" +
                "    \"to_y\": 320,\n" +
                "    \"from_value\": 1,\n" +
                "    \"to_value\": -1\n" +
                "  },\n" +
                "  \"argument2\": {\n" +
                "    \"type\": \"minecraft:noise\",\n" +
                "    \"noise\": \"minecraft:gravel\",\n" +
                "    \"xz_scale\": NR,\n".replace("NR",""+planetData.getFloat("nr1")) +
                "    \"y_scale\": NR\n".replace("NR",""+planetData.getFloat("nr2")) +
                "  }\n" +
                "}";
    }


    private static String genLakes(CompoundTag planetData, String uuid, RandomSource randomSource)
    {
        StringBuilder features = new StringBuilder();


        for (int i = 0; i < 1; i++) {

            List<Material> materials = FLUIDABLE.stream().filter(a->
            {
                int temp = a.getFluid().getFluidType().getTemperature();

                //if the fluid temperature is >300 it's not set as a liquid at room temperature so is *probably* molten.
                //in this case, we need the planet to be warmer than its liquid state
                if(temp<=planetData.getInt("temperature") && temp>300)
                {
                    return true;
                }
                //if the fluid temeperature <301 you probably need to cool it to get it as a liquid, or its liquid at room temperature
                //in this case, we want the planet to be colder than its liquid state
                if(planetData.getInt("temperature")<=temp && temp<301)
                {
                    return true;
                }
                //since we only have 1 number (what temperature it is when its a liquid) we can't infer when something freezes solid
                //or when something evaporates.

                return false;
            }).toList();
            String matName;
            String fluidName;

            //these first two conditions should only trigger if a planet is really really hot or really really cold.
            //and they should only trigger at all if we are in a gamestate where we have no other fluids
            if(materials.isEmpty() && planetData.getInt("temperature")<301)
            {
                matName = "ice";
                fluidName = "minecraft:packed_ice";
            }
            else if(materials.isEmpty() && planetData.getInt("temperature")>300)
            {
                matName = "lava";
                fluidName = "minecraft:lava";
            }
            else
            {
                Material material = materials.get(randomSource.nextInt(materials.size()));
                fluidName = BuiltInRegistries.FLUID.getKey(material.getFluid()).toString();
                matName = material.getName();
            }

            ListTag lakes;
            if(planetData.contains("lakeFluids"))
            {
                lakes = (ListTag) planetData.get("lakeFluids");
            }
            else
            {
                lakes = new ListTag();
            }
            lakes.add(StringTag.valueOf(fluidName));


            List<String> lake_placed_feature = List.of("{\n" +
                    "  \"feature\": \"LAKE\",\n".replace("LAKE","dataplanets:"+matName+"_lake") +
                    "  \"placement\": [\n" +
                    "    {\n" +
                    "      \"type\": \"minecraft:rarity_filter\",\n" +
                    "      \"chance\": 200\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"type\": \"minecraft:in_square\"\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"type\": \"minecraft:heightmap\",\n" +
                    "      \"heightmap\": \"WORLD_SURFACE_WG\"\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"type\": \"minecraft:biome\"\n" +
                    "    }\n" +
                    "  ]\n" +
                    "}");
            List<String> lake_configured_feature = List.of("{\n" +
                    "  \"type\": \"minecraft:lake\",\n" +
                    "  \"config\": {\n" +
                    "    \"fluid\": {\n" +
                    "      \"type\": \"minecraft:simple_state_provider\",\n" +
                    "      \"state\": {\n" +
                    "        \"Name\": \"FLUID\",\n".replace("FLUID",fluidName) +
                    "        \"Properties\": {\n" +
                    "          \"level\": \"0\"\n" +
                    "        }\n" +
                    "      }\n" +
                    "    },\n" +
                    "    \"barrier\": {\n" +
                    "      \"type\": \"minecraft:simple_state_provider\",\n" +
                    "      \"state\": {\n" +
                    "        \"Name\": \"minecraft:stone\"\n" +
                    "      }\n" +
                    "    }\n" +
                    "  }\n" +
                    "}");

            try {
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\worldgen\\placed_feature\\"+matName+"_lake"+".json"),lake_placed_feature);
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\worldgen\\configured_feature\\"+matName+"_lake"+".json"),lake_configured_feature);
                features.append("\"dataplanets:").append(matName).append("_lake\"");
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }



        return features.toString();
    }
    private static String genRocks(CompoundTag planetData, String uuid, RandomSource randomSource)
    {
        StringBuilder features = new StringBuilder();
        String matName = SURFACE_BLOCKS[randomSource.nextInt(SURFACE_BLOCKS.length)];
        planetData.putString("rock_block",matName);
        String unqualified = matName.split(":")[1];

        for (int i = 0; i < 1; i++) {



            List<String> placed_feature = List.of("{\n" +
                    "  \"feature\": \"dataplanets:EE_rocks\",\n".replace("EE",unqualified) +
                    "  \"placement\": [\n" +
                    "    {\n" +
                    "      \"type\": \"minecraft:count\",\n" +
                    "      \"count\": 2\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"type\": \"minecraft:in_square\"\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"type\": \"minecraft:heightmap\",\n" +
                    "      \"heightmap\": \"MOTION_BLOCKING\"\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"type\": \"minecraft:biome\"\n" +
                    "    }\n" +
                    "  ]\n" +
                    "}");
            List<String> configured_feature = List.of("{\n" +
                    "  \"type\": \"minecraft:forest_rock\",\n" +
                    "  \"config\": {\n" +
                    "    \"state\": {\n" +
                    "      \"Name\": \"EE\"\n".replace("EE",matName) +
                    "    }\n" +
                    "  }\n" +
                    "}");

            try {
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\worldgen\\placed_feature\\"+unqualified+"_rocks"+".json"),placed_feature);
                writeLinesCond(new File(DATALOC+"pack"+uuid+"\\data\\dataplanets\\worldgen\\configured_feature\\"+unqualified+"_rocks"+".json"),configured_feature);
                features.append(",\"dataplanets:").append(unqualified).append("_rocks\"");
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }



        return features.toString();
    }

    static boolean writeCond = false;
    private static void writeLinesCond(File file, List<String> strings) throws IOException {
        if(writeCond)
        {
            FileUtils.writeLines(file,strings);
        }
    }
}
